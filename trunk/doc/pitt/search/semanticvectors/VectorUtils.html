<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_11) on Fri Apr 24 15:26:25 EDT 2009 -->
<TITLE>
VectorUtils
</TITLE>

<META NAME="date" CONTENT="2009-04-24">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="VectorUtils";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/VectorUtils.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../pitt/search/semanticvectors/VectorStoreWriter.html" title="class in pitt.search.semanticvectors"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../pitt/search/semanticvectors/ZeroVectorException.html" title="class in pitt.search.semanticvectors"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?pitt/search/semanticvectors/VectorUtils.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="VectorUtils.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
pitt.search.semanticvectors</FONT>
<BR>
Class VectorUtils</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><B>pitt.search.semanticvectors.VectorUtils</B>
</PRE>
<HR>
<DL>
<DT><PRE>public class <B>VectorUtils</B><DT>extends java.lang.Object</DL>
</PRE>

<P>
This class provides standard vector methods, e.g., cosine measure,
 normalization, tensor utils.
<P>

<P>
<HR>

<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../pitt/search/semanticvectors/VectorUtils.html#VectorUtils()">VectorUtils</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../pitt/search/semanticvectors/VectorUtils.html#addVectors(float[], float[], int)">addVectors</A></B>(float[]&nbsp;vector1,
           float[]&nbsp;vector2,
           int&nbsp;weight)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Add two vectors.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../pitt/search/semanticvectors/VectorUtils.html#addVectors(float[], short[], int)">addVectors</A></B>(float[]&nbsp;vector1,
           short[]&nbsp;sparseVector,
           int&nbsp;weight)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Add two vectors.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float[][]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../pitt/search/semanticvectors/VectorUtils.html#createZeroTensor(int)">createZeroTensor</A></B>(int&nbsp;dim)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../pitt/search/semanticvectors/VectorUtils.html#euclideanDistance(float[], float[])">euclideanDistance</A></B>(float[]&nbsp;vec1,
                  float[]&nbsp;vec2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../pitt/search/semanticvectors/VectorUtils.html#Floats(double[])">Floats</A></B>(double[]&nbsp;vector)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float[][]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../pitt/search/semanticvectors/VectorUtils.html#Floats(double[][])">Floats</A></B>(double[][]&nbsp;matrix)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;short[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../pitt/search/semanticvectors/VectorUtils.html#floatVectorToSparseVector(float[], int)">floatVectorToSparseVector</A></B>(float[]&nbsp;floatVector,
                          int&nbsp;seedLength)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Take a vector of floats and simplify by quantizing to a sparse format.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;short[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../pitt/search/semanticvectors/VectorUtils.html#generateRandomVector(int, java.util.Random)">generateRandomVector</A></B>(int&nbsp;seedLength,
                     java.util.Random&nbsp;random)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generates a basic sparse vector (dimension = Flags.dimension)
 with mainly zeros and some 1 and -1 entries (seedLength/2 of each)
 each vector is an array of length seedLength containing 1+ the index of a non-zero
 value, signed according to whether this is a + or -1.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../pitt/search/semanticvectors/VectorUtils.html#getConvolutionFromTensor(float[][])">getConvolutionFromTensor</A></B>(float[][]&nbsp;tensor)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the convolution of two vectors; see Plate,
 Holographic Reduced Representation, p.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../pitt/search/semanticvectors/VectorUtils.html#getConvolutionFromVectors(float[], float[])">getConvolutionFromVectors</A></B>(float[]&nbsp;vec1,
                          float[]&nbsp;vec2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the convolution of two vectors; see Plate,
 Holographic Reduced Representation, p.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../pitt/search/semanticvectors/VectorUtils.html#getInnerProduct(float[][], float[][])">getInnerProduct</A></B>(float[][]&nbsp;ten1,
                float[][]&nbsp;ten2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the inner product of two tensors.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../pitt/search/semanticvectors/VectorUtils.html#getNearestVector(float[], float[][])">getNearestVector</A></B>(float[]&nbsp;vector,
                 float[][]&nbsp;candidates)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get nearest vector from list of candidates.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;short[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../pitt/search/semanticvectors/VectorUtils.html#getNLargestPositions(float[], int)">getNLargestPositions</A></B>(float[]&nbsp;values,
                     int&nbsp;numResults)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Given an array of floats, return an array of indices to the n largest values.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float[][]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../pitt/search/semanticvectors/VectorUtils.html#getNormalizedTensor(float[][])">getNormalizedTensor</A></B>(float[][]&nbsp;tensor)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the normalized version of a 2 tensor, i.e.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../pitt/search/semanticvectors/VectorUtils.html#getNormalizedVector(float[])">getNormalizedVector</A></B>(float[]&nbsp;vec)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the normalized version of a vector, i.e.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float[][]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../pitt/search/semanticvectors/VectorUtils.html#getOuterProduct(float[], float[])">getOuterProduct</A></B>(float[]&nbsp;vec1,
                float[]&nbsp;vec2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a 2-tensor which is the outer product of 2 vectors.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../pitt/search/semanticvectors/VectorUtils.html#getSumScalarProduct(float[], java.util.ArrayList)">getSumScalarProduct</A></B>(float[]&nbsp;testVector,
                    java.util.ArrayList&lt;float[]&gt;&nbsp;vectors)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sums the scalar products of a vector and each member of a list of
 vectors.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float[][]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../pitt/search/semanticvectors/VectorUtils.html#getTensorSum(float[][], float[][])">getTensorSum</A></B>(float[][]&nbsp;ten1,
             float[][]&nbsp;ten2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the sum of two tensors.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../pitt/search/semanticvectors/VectorUtils.html#isZeroTensor(float[][])">isZeroTensor</A></B>(float[][]&nbsp;ten)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../pitt/search/semanticvectors/VectorUtils.html#isZeroVector(float[])">isZeroVector</A></B>(float[]&nbsp;vec)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../pitt/search/semanticvectors/VectorUtils.html#orthogonalizeVectors(java.util.ArrayList)">orthogonalizeVectors</A></B>(java.util.ArrayList&lt;float[]&gt;&nbsp;vectors)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The orthogonalize function takes an array of vectors and
 orthogonalizes them using the Gram-Schmidt process.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../pitt/search/semanticvectors/VectorUtils.html#permuteVector(float[], int)">permuteVector</A></B>(float[]&nbsp;indexVector,
              int&nbsp;rotation)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method implements rotation as a form of vector permutation,
 as described in Sahlgren, Holst and Kanervi 2008.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;short[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../pitt/search/semanticvectors/VectorUtils.html#permuteVector(short[], int)">permuteVector</A></B>(short[]&nbsp;indexVector,
              int&nbsp;rotation)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method implements rotation as a form of vector permutation,
 as described in Sahlgren, Holst and Kanervi 2008.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../pitt/search/semanticvectors/VectorUtils.html#printMatrix(float[][])">printMatrix</A></B>(float[][]&nbsp;matrix)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../pitt/search/semanticvectors/VectorUtils.html#printVector(float[])">printVector</A></B>(float[]&nbsp;vector)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../pitt/search/semanticvectors/VectorUtils.html#scalarProduct(float[], float[])">scalarProduct</A></B>(float[]&nbsp;vec1,
              float[]&nbsp;vec2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the scalar product (dot product) of two vectors
 for normalized vectors this is the same as cosine similarity.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../pitt/search/semanticvectors/VectorUtils.html#sparseVectorToFloatVector(short[], int)">sparseVectorToFloatVector</A></B>(short[]&nbsp;sparseVector,
                          int&nbsp;dimension)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Translate sparse format (listing of offsets) into full float vector.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="VectorUtils()"><!-- --></A><H3>
VectorUtils</H3>
<PRE>
public <B>VectorUtils</B>()</PRE>
<DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="printVector(float[])"><!-- --></A><H3>
printVector</H3>
<PRE>
public static void <B>printVector</B>(float[]&nbsp;vector)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="printMatrix(float[][])"><!-- --></A><H3>
printMatrix</H3>
<PRE>
public static void <B>printMatrix</B>(float[][]&nbsp;matrix)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="Floats(double[])"><!-- --></A><H3>
Floats</H3>
<PRE>
public static float[] <B>Floats</B>(double[]&nbsp;vector)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="Floats(double[][])"><!-- --></A><H3>
Floats</H3>
<PRE>
public static float[][] <B>Floats</B>(double[][]&nbsp;matrix)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="isZeroVector(float[])"><!-- --></A><H3>
isZeroVector</H3>
<PRE>
public static boolean <B>isZeroVector</B>(float[]&nbsp;vec)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="isZeroTensor(float[][])"><!-- --></A><H3>
isZeroTensor</H3>
<PRE>
public static boolean <B>isZeroTensor</B>(float[][]&nbsp;ten)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="createZeroTensor(int)"><!-- --></A><H3>
createZeroTensor</H3>
<PRE>
public static float[][] <B>createZeroTensor</B>(int&nbsp;dim)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="scalarProduct(float[], float[])"><!-- --></A><H3>
scalarProduct</H3>
<PRE>
public static float <B>scalarProduct</B>(float[]&nbsp;vec1,
                                  float[]&nbsp;vec2)</PRE>
<DL>
<DD>Returns the scalar product (dot product) of two vectors
 for normalized vectors this is the same as cosine similarity.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>vec1</CODE> - First vector.<DD><CODE>vec2</CODE> - Second vector.</DL>
</DD>
</DL>
<HR>

<A NAME="euclideanDistance(float[], float[])"><!-- --></A><H3>
euclideanDistance</H3>
<PRE>
public static float <B>euclideanDistance</B>(float[]&nbsp;vec1,
                                      float[]&nbsp;vec2)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getNearestVector(float[], float[][])"><!-- --></A><H3>
getNearestVector</H3>
<PRE>
public static int <B>getNearestVector</B>(float[]&nbsp;vector,
                                   float[][]&nbsp;candidates)</PRE>
<DL>
<DD>Get nearest vector from list of candidates.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>vector</CODE> - The vector whose nearest neighbor is to be found.<DD><CODE>candidates</CODE> - The list of vectors from whoe the nearest is to be chosen.
<DT><B>Returns:</B><DD>Integer value referencing the position in the candidate list of the nearest vector.</DL>
</DD>
</DL>
<HR>

<A NAME="getNormalizedVector(float[])"><!-- --></A><H3>
getNormalizedVector</H3>
<PRE>
public static float[] <B>getNormalizedVector</B>(float[]&nbsp;vec)</PRE>
<DL>
<DD>Returns the normalized version of a vector, i.e. same direction,
 unit length.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>vec</CODE> - Vector whose normalized version is requested.</DL>
</DD>
</DL>
<HR>

<A NAME="getNormalizedTensor(float[][])"><!-- --></A><H3>
getNormalizedTensor</H3>
<PRE>
public static float[][] <B>getNormalizedTensor</B>(float[][]&nbsp;tensor)</PRE>
<DL>
<DD>Returns the normalized version of a 2 tensor, i.e. an array of
 arrays of floats.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getOuterProduct(float[], float[])"><!-- --></A><H3>
getOuterProduct</H3>
<PRE>
public static float[][] <B>getOuterProduct</B>(float[]&nbsp;vec1,
                                        float[]&nbsp;vec2)</PRE>
<DL>
<DD>Returns a 2-tensor which is the outer product of 2 vectors.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getTensorSum(float[][], float[][])"><!-- --></A><H3>
getTensorSum</H3>
<PRE>
public static float[][] <B>getTensorSum</B>(float[][]&nbsp;ten1,
                                     float[][]&nbsp;ten2)</PRE>
<DL>
<DD>Returns the sum of two tensors.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getInnerProduct(float[][], float[][])"><!-- --></A><H3>
getInnerProduct</H3>
<PRE>
public static float <B>getInnerProduct</B>(float[][]&nbsp;ten1,
                                    float[][]&nbsp;ten2)</PRE>
<DL>
<DD>Returns the inner product of two tensors.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getConvolutionFromTensor(float[][])"><!-- --></A><H3>
getConvolutionFromTensor</H3>
<PRE>
public static float[] <B>getConvolutionFromTensor</B>(float[][]&nbsp;tensor)</PRE>
<DL>
<DD>Returns the convolution of two vectors; see Plate,
 Holographic Reduced Representation, p. 76.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getConvolutionFromVectors(float[], float[])"><!-- --></A><H3>
getConvolutionFromVectors</H3>
<PRE>
public static float[] <B>getConvolutionFromVectors</B>(float[]&nbsp;vec1,
                                                float[]&nbsp;vec2)</PRE>
<DL>
<DD>Returns the convolution of two vectors; see Plate,
 Holographic Reduced Representation, p. 76.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getSumScalarProduct(float[], java.util.ArrayList)"><!-- --></A><H3>
getSumScalarProduct</H3>
<PRE>
public static float <B>getSumScalarProduct</B>(float[]&nbsp;testVector,
                                        java.util.ArrayList&lt;float[]&gt;&nbsp;vectors)</PRE>
<DL>
<DD>Sums the scalar products of a vector and each member of a list of
 vectors.  If the list is orthonormal, this gives the cosine
 similarity of the test vector and the subspace generated by the
 orthonormal vectors.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="orthogonalizeVectors(java.util.ArrayList)"><!-- --></A><H3>
orthogonalizeVectors</H3>
<PRE>
public static boolean <B>orthogonalizeVectors</B>(java.util.ArrayList&lt;float[]&gt;&nbsp;vectors)</PRE>
<DL>
<DD>The orthogonalize function takes an array of vectors and
 orthogonalizes them using the Gram-Schmidt process. The vectors
 are orthogonalized in place, so there is no return value.  Note
 that the output of this function is order dependent, in
 particular, the jth vector in the array will be made orthogonal
 to all the previous vectors. Since this means that the last
 vector is orthogonal to all the others, this can be used as a
 negation function to give an vector for
 vectors[last] NOT (vectors[0] OR ... OR vectors[last - 1].
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>vectors</CODE> - ArrayList of vectors (which are themselves arrays of
 floats) to be orthogonalized in place.</DL>
</DD>
</DL>
<HR>

<A NAME="generateRandomVector(int, java.util.Random)"><!-- --></A><H3>
generateRandomVector</H3>
<PRE>
public static short[] <B>generateRandomVector</B>(int&nbsp;seedLength,
                                           java.util.Random&nbsp;random)</PRE>
<DL>
<DD>Generates a basic sparse vector (dimension = Flags.dimension)
 with mainly zeros and some 1 and -1 entries (seedLength/2 of each)
 each vector is an array of length seedLength containing 1+ the index of a non-zero
 value, signed according to whether this is a + or -1.
 <br>
 e.g. +20 would indicate a +1 in position 19, +1 would indicate a +1 in position 0.
      -20 would indicate a -1 in position 19, -1 would indicate a -1 in position 0.
 <br>
 The extra offset of +1 is because position 0 would be unsigned,
 and would therefore be wasted. Consequently we've chosen to make
 the code slightly more complicated to make the implementation
 slightly more space efficient.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>Sparse representation of basic ternary vector. Array of
 short signed integers, indices to the array locations where a
 +/-1 entry is located.</DL>
</DD>
</DL>
<HR>

<A NAME="getNLargestPositions(float[], int)"><!-- --></A><H3>
getNLargestPositions</H3>
<PRE>
public static short[] <B>getNLargestPositions</B>(float[]&nbsp;values,
                                           int&nbsp;numResults)</PRE>
<DL>
<DD>Given an array of floats, return an array of indices to the n largest values.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="floatVectorToSparseVector(float[], int)"><!-- --></A><H3>
floatVectorToSparseVector</H3>
<PRE>
public static short[] <B>floatVectorToSparseVector</B>(float[]&nbsp;floatVector,
                                                int&nbsp;seedLength)</PRE>
<DL>
<DD>Take a vector of floats and simplify by quantizing to a sparse format. Lossy.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="sparseVectorToFloatVector(short[], int)"><!-- --></A><H3>
sparseVectorToFloatVector</H3>
<PRE>
public static float[] <B>sparseVectorToFloatVector</B>(short[]&nbsp;sparseVector,
                                                int&nbsp;dimension)</PRE>
<DL>
<DD>Translate sparse format (listing of offsets) into full float vector.
 The random vector is in condensed (signed index + 1)
 representation, and is converted to a full float vector by adding -1 or +1 to the
 location (index - 1) according to the sign of the index.
 (The -1 and +1 are necessary because there is no signed
 version of 0, so we'd have no way of telling that the
 zeroth position in the array should be plus or minus 1.)
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="permuteVector(short[], int)"><!-- --></A><H3>
permuteVector</H3>
<PRE>
public static short[] <B>permuteVector</B>(short[]&nbsp;indexVector,
                                    int&nbsp;rotation)</PRE>
<DL>
<DD>This method implements rotation as a form of vector permutation,
 as described in Sahlgren, Holst and Kanervi 2008. This supports
 encoding of N-grams, as rotating random vectors serves as a convenient
 alternative to random permutation
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>indexVector</CODE> - the sparse vector to be permuted<DD><CODE>rotation</CODE> - the direction and number of places to rotate
<DT><B>Returns:</B><DD>sparse vector with permutation</DL>
</DD>
</DL>
<HR>

<A NAME="permuteVector(float[], int)"><!-- --></A><H3>
permuteVector</H3>
<PRE>
public static float[] <B>permuteVector</B>(float[]&nbsp;indexVector,
                                    int&nbsp;rotation)</PRE>
<DL>
<DD>This method implements rotation as a form of vector permutation,
 as described in Sahlgren, Holst and Kanervi 2008. This supports
 encoding of N-grams, as rotating random vectors serves as a convenient
 alternative to random permutation
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>indexVector</CODE> - the sparse vector to be permuted<DD><CODE>rotation</CODE> - the direction and number of places to rotate
<DT><B>Returns:</B><DD>vector with permutation</DL>
</DD>
</DL>
<HR>

<A NAME="addVectors(float[], float[], int)"><!-- --></A><H3>
addVectors</H3>
<PRE>
public static float[] <B>addVectors</B>(float[]&nbsp;vector1,
                                 float[]&nbsp;vector2,
                                 int&nbsp;weight)</PRE>
<DL>
<DD>Add two vectors. Overloaded vector to handle either float[] + float[] or float[] + sparse vector
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>vector1</CODE> - initial vector<DD><CODE>vector2</CODE> - vector to be added<DD><CODE>weight</CODE> - weight (presently only term frequency implemented - may need this to take floats later)
<DT><B>Returns:</B><DD>sum of two vectors</DL>
</DD>
</DL>
<HR>

<A NAME="addVectors(float[], short[], int)"><!-- --></A><H3>
addVectors</H3>
<PRE>
public static float[] <B>addVectors</B>(float[]&nbsp;vector1,
                                 short[]&nbsp;sparseVector,
                                 int&nbsp;weight)</PRE>
<DL>
<DD>Add two vectors. Overloaded vector to handle either float[] + float[] or float[] + sparse vector
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>vector1</CODE> - initial vector<DD><CODE>sparseVector</CODE> - vector to be added<DD><CODE>weight</CODE> - weight (presently only term frequency implemented - may need this to take floats later)
<DT><B>Returns:</B><DD>sum of two vectors</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/VectorUtils.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../pitt/search/semanticvectors/VectorStoreWriter.html" title="class in pitt.search.semanticvectors"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../pitt/search/semanticvectors/ZeroVectorException.html" title="class in pitt.search.semanticvectors"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?pitt/search/semanticvectors/VectorUtils.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="VectorUtils.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
